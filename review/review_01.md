# 1단원 복습 문제

## 1번
### a)
1. (1, 0) → 0
2. (0, 1) → 0

### b)
1. (1, 0) → 0
2. (0, 1) → 1

### c)
1. (1, 0) → 0
2. (0, 1) → 1

## 2번
### a)
(0, 0) → 0   
(0, 1) → 0   
(1, 0) → 0   
(1, 1) → 1   

답은 AND연산이다.

### b)
(0, 0) → 0   
(0, 1) → 1   
(1, 0) → 1   
(1, 1) → 0

답은 XOR연산이다.

## 3번
### a)
#### 첫번째 펄스   
하 : 플립0→1 출력0→1   
상 : 플립1→0 출력0→0 (변화없음)   
출력 : (1, 0)

#### 두번째 펄스
하 : 플립0→1 출력1→0   
상 : 플립0→1 출력0→1  
출력 : (0, 1)

#### 세번째 펄스
하 : 플립0→1 출력0→1   
상 : 플립1→0 출력1→1 (변화없음)   
출력 : (1, 1)

#### 네번째 펄스
하 : 플립0→1 출력1→0   
상 : 플립0→1 출력1→0   
출력 : (0, 0)

### b)

A : 하 AND ~상    
B : ~하 AND 상   
C : 하 AND 상

#### 첫번째 클락 펄스   
하 : 플립0→1 출력0→1   
상 : 플립0→0 출력0→0 (변화없음)   
출력 : (1, 0)  
최종 출력 : (1, 0, 0)

#### 두번째 클락 펄스
하 : 플립0→1 출력1→0   
상 : 플립0→1 출력0→1  
출력 : (0, 1)  
최종 출력 : (0, 1, 0)

#### 세번째 클락 펄스
하 : 플립0→1 출력0→1   
상 : 플립1→0 출력1→1 (변화없음)   
출력 : (1, 1)  
최종 출력 : (0, 0, 1)

#### 네번째 클락 펄스
하 : 플립0→1 출력1→0   
상 : 플립0→1 출력1→0   
출력 : (0, 0)   
최종 출력 : (0, 0, 0)

이후로는 반복된다.

B에서 1이 나오는 클락 펄스 : 2, 6, 10번째  
C에서 1이 나오는 클락 펄스 : 3, 7, 11번째  
4번째 클락 펄스 : 어떤 출력에서도 1이 나오지 않는다.

## 4번
위쪽 입력이 순간적으로 0으로 바뀌면  
출력이 1이 되고, 1이 위쪽 AND게이트로 들어가므로 위쪽 입력이 1로 돌아가더라도 출력이 그대로 유지된다.  

아래쪽 입력이 순간적으로 0으로 바뀌면   
출력이 0이 되고, 0이 아래쪽 AND게이트로 들어가므로 아래쪽 입력이 1로 돌아가더라도 출력이 그대로 유지된다.   

<img src="https://user-images.githubusercontent.com/98504939/170405839-00ddaccd-cf1d-4574-b42e-0d2744d95e50.png" width=30%>

## 5번
00 02   
01 53  
02 01  
03 53

## 6번
두 자리 16진수의 크기는 1바이트다.  
따라서 256개까지의 셀이 존재할 수 있다.

네 자리 16진수의 크기는 2바이트이므로,  
이 경우에는 65536개까지의 셀이 존재할 수 있다.

## 7번
### a)
CD

답은 1100 1101이다.

### b)
67

답은 0110 0111이다.

### c)
9A

답은 1001 1010이다.

### d)
FF

답은 1111 1111이다.

### e)
10

답은 0001 0000이다.

## 8번
### a)
8F

1000 1111

답은 1이다.

### b)
FF

1111 1111

답은 1이다.

### c)
6F

0110 1111

답은 0이다.

### d)
1F

0001 1111

답은 0이다.

## 9번
### a)
1010 0000 1010

A 0 A

답은 A0A다.

### b)
1100 0111 1011

C 7 B

답은 C7B다.

### c)
0000 1011 1110

0 B E

답은 0BE다.

## 10번
하나의 픽셀을 표현하려면 3바이트가 필요하다. (R, G, B 각 1바이트 씩)  
1024 * 1024 * 3 = 3,145,728바이트 = 약 25.17MB (사진 1장 크기)  
256 / 25.17 = 10.17...   

최대 10장까지 저장할 수 있다.

## 11번
하나의 픽셀이 16비트, 즉 2바이트를 필요로 하는 경우다.  
1024 * 768 * 2 = 1,572,864바이트   

총 1,572,864개의 메모리 셀이 필요하다.

## 12번
### a)
1. 기계적 동작을 필요로 하지 않기 때문에 실행 속도가 빠르다.
2. 정보를 읽어올 필요가 없다??

### b)
1. 용량 단위 당 가격이 저렴하다.
2. 탈착? 수명이 길다?

## 13번
합리적이지 않다.  
CD/DVD는 그정도 용량이 되지도 않거니와, 한번 저장한 데이터를 부분적으로 수정하는 것이 불가능하기 때문에  
하드디스크의 대체재로 적합하지 않다.

## 14번
100 * 50 * 2 = 10,000바이트  
10,000 / 1024 = 9.76...  

최소 10개의 섹터가 필요하다.

## 15번
ASCII는 8비트, 즉 1바이트다.  
3500 * 400 * 1 = 1,400,000바이트

ASCII를 사용한 경우, 1,400,000바이트가 필요하다.   
유니코드를 사용한 경우, 그 두 배인 2,800,000바이트가 필요하다.

## 16번
대기시간은 데이터 전송 요청과 데이터 수신 사이의 총 소요 시간을 말한다.  

분당 3600회 회전 = 초당 60회 회전 = 0.01666초당 1회 회전
회전지연 = 0.01666초 / 2 = 0.00833초 = 8.3밀리초

대기시간 = 탐색시간 + 0.0083초(회전지연) + 요청 및 수신에 걸리는 시간

정확한 대기시간을 알 수 없는 거 아닌가?

## 17번
접근시간 = 탐색시간 + 회전지연

초당 360번 회전 = 0.002777초당 1회 회전
회전지연 = 0.002777 / 2 = 0.001333초 = 1.3밀리초

평균접근시간 = 10밀리초 + 1.3밀리초 = 11.3밀리초

답은 11.3밀리초다.

## 18번
## 19번
## 20번
## 21번
## 22번
## 23번
## 24번
## 25번
## 26번
## 27번
## 28번
## 29번
## 30번
## 31번
## 32번
## 33번
## 34번
## 35번
## 36번
## 37번
## 38번
## 39번
## 40번
## 41번
## 42번
## 43번
## 44번
## 45번
## 46번
## 47번
## 48번
## 49번
## 50번
## 51번
## 52번
## 53번
## 54번
## 55번
## 56번
## 57번
## 58번
## 59번
## 60번
## 61번
