# 2.2 연습문제

## 1번
사실상 이동이 아니라 복사가 일어나는 형태이기 때문이다.

(+ 이동(move)이라는 용어는 종종 한 장소에서 제거하여 다른 장소에 옮기며, 따라서 빈 공간을 남긴다는 의미를 내포하고 있다.  
그러나 대부분의 경우 컴퓨터에서 이러한 제거는 일어나지 않는다. 대신 대부분의 경우 이동 대생 객체가 새로운 장소로 복사될 (또는 복제될) 뿐이다.)

## 2번
~~목적지 이름을 특정 메모리 셀에서 LOAD해오도록 하면 명령이 변경되었을 때 해당 메모리 셀 안의 내용만 바꿔주면 된다.~~

(+ 상대적 주소법이라는 일반적인 기법에서는 어디로 점프하느냐 대신 얼마나 멀리 점프하느냐를 표현한다.  
예를 들면, 앞쪽으로 세 명령을 지난 위치로 점프하거나 뒤쪽으로 두 명령 전으로 점프하거나 할 수 있다.  
그러나 나중에 점프 명령과 점프의 목적지 사이에 추가의 명령들이 삽입될 경우 이러한 문장들이 변경되어야 함에 유의해야 한다.)

## 3번
무조건 점프이다.  
0은 항상 0과 같기 때문이다.

(+ 둘 다 답이 될 수 있다.  
명령의 형식으로 보면 조건부 점프에 해당된다.  
그러나 0이 0과 같다는 조건은 항상 참이므로 아무 조건이 없는 경우와 동일하게 점프는 항상 실행될 것이다.  
이러한 명령은 효율적 설계를 제공한다는 이유로 실제 컴퓨터들에서 제공될 수 있다.  
예를 들어 어떤 컴퓨터가 "if ... jump to ..."와 같은 구조의 명령을 실행할 수 있도록 설계된다면,  
이러한 명령 형식은 조건부 점프와 무조건 점프 모두의 표현에 사용될 수 있다.)

## 4번
0001 0101 0110 1100  
0001 0110 0110 1101  
0101 0000 0101 0110  
0011 0000 0110 1110  
1100 0000 0000 0000

## 5번
### a)
368A

6번 레지스터의 비트 패턴을 주소가 8A인 메모리 셀에 STORE하라.

### b)
BADE

A번 레지스터의 비트 패턴이 0번 레지스터의 비트 패턴과 같을 경우, 주소가 DE인 메모리 셀에 위치한 명령으로 JUMP한다.  
그렇지 않으면, 정상적인 실행 순서에 따라 진행한다.

### c)
803C

3번 레지스터와 C번 레지스터의 비트 패턴을 AND하여 그 결과를 0번 레지스터에 넣는다.

### d)
40F4

F번 레지스터의 비트 패턴을 4번 레지스터에 MOVE한다.

## 6번
15AB와 25AB의 차이

15AB는 주소가 AB인 메모리 셀 안의 비트 패턴을 5번 레지스터에 LOAD하는 것이고,  
25AB는 비트 패턴 AB를 5번 레지스터에 LOAD하는 것이다.

## 7번
### a)
16진수 56을 3번 레지스터에 LOAD하라.

2356

### b)
5번 레지스터를 오른쪽으로 3비트만큼 ROTATE하라.

A503

### c)
A번 레지스터의 내용과 5번 레지스터의 내용에 대해 AND 연산을 수행하고, 그 결과를 0번 레지스터에 넣어라.

80A5
